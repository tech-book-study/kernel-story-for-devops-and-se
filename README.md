# 2장 top을 통해 살펴보는 프로세스 정보들

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa91ffaa-6521-4a7a-8a39-1504c0b0bdc9/_2020-08-15__8.57.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa91ffaa-6521-4a7a-8a39-1504c0b0bdc9/_2020-08-15__8.57.52.png)

top 명령어로 서버 정보를 볼 수 있다.

3 days: 현재 구동 된지 3일 정도 되었음.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b299189-f3a0-4a76-b825-077137e6d83a/_2020-08-15__8.58.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b299189-f3a0-4a76-b825-077137e6d83a/_2020-08-15__8.58.47.png)

PR: 프로세스 실행 우선순위

NI: PR을 얼마만큼 조정할 것인가

VIRT,RES,SHR: 프로세스가 사용하는 메모리의 양에 대한 것

VIRT: 할당된 가상메모리의 전체 크기. 

RES: 그 중에 실재로 메모리에 올려서 사용하고 있는 물리 메모리의 크기 (그렇기 때문에 실제 메모리 점유율이 높은 프로세스를 찾기 위해서는 RES 영역이 높은 프로세스를 찾아야 한다)

SHR: 다른 프로세스와 공유하고 있는 메모리의 크기

S: 프로세스의 상태를 나타낸다.

VIRT는 malloc과 같은 시스템 콜로 필요로 하는 메모리 영역을 할당해 달라고 요청을 하면 커널은 프로세스가 사용할 수 있는 가상 메모리주소를 전달해준다. ⇒ Memory Commit

그 후 프로세스가 할당받은 메모리 영역에 실제로 쓰기 작업을 하면 Page fault가 발생하며 실제 물리 메모리에 프로세스의 가상 메모리 공간을 매핑한다. 

한도 끝도 없이 늘어날까? → vm.overcommit_memory라는 파라미터로 그렇게 할 수 도있고 못하게 할 수도 있다. 

왜 즉시 할당하지 않는 것일까? → fork()와 같은 새로운 프로세스를 만들기 위한 콜을 처리해야 하기 때문이다.

### 프로세스의 상태

S - Process Status를 의미

D: uninterrubtable sleep 상태로 프로세스가 디스크 혹은 네트워크 작업을 하게 되면 요청이 도착할 때 까지 아무것도 할 수 없기 때문에 CPU에 대한 사용권을 다른 프로세스에게 넘기고 자신을 D로 마킹한다. 

R: 실행중인 프로세스이기 때문에 실제 CPU 자원을 소모한다.

S: sleeping 상태의 프로세스

T: strace등으로 프로세스의 시스템 콜을 추적하고 있는 상태로 보통의 시스템에서는 자주 볼 수 없다.

Z: zombie상태의 프로세스로 부모 프로세스가 죽은 자식 프로세스를 의미한다.

D 상태의 프로세스가 많다면 특정 요청을 기다리고 있는 것이고 다시 R상태로 돌아가야 하기 때문에 시스템 부하를 계산하는데 포함된다.

Z 프로세스는 시스템의 리소스를 차지하지 않아서 그 자체는 문제가 되지 않는다. 하지만 pid를 점유하고 있기 때문에 새로운 프로세스에 pid를 할당하지 못하여 고갈이 되는 문제가 발생할 수 있다.

### 프로세스의 우선순위

기본적으로 모든 프로세스는 20의 우선순위 값을 갖는다. 여기에 NI를 주면 우선순위값이 바뀌게 된다. 이 우선순위 값이 낮을 수록 더 빨리 실행된다.

# 3장 Load Average와 시스템 부하

Load Average는 얼마나 많은 프로세스가 실행 중 혹은 실행 대기 중이냐를 의미하는 수치이다. 이 값은 절대적이 아니라 상대적인데 계산과정이 시스템에 있는 CPU Core 수가 몇 개냐에 따라 달라지기 때문이다.

Kernel Timer가 주기적으로 프로세스의 개수를 센다.

Load Average가 높다는 것은 CPU를 사용하려는 프로세스가 많다는 것 뿐만 아니라 I/O쪽에 병목이 생겨서 I/O작업을 대기하는 프로세스가 많을 수도 있다는 이야기다. → 그렇기 때문에 Load Average가 높다고 단순히 CPU가 더 많은 장비를 사용하는 것으로 해결할 수 없다.

```bash
vmstat
```

vmstat 명령어로 시스템의 상태를 확인해 볼 수 있다.

r: 실행되기를 기다리거나 현재 실행되고 있는 프로세스의 개수

b: I/O를 위해 대기열에 있는 프로세스의 개수

참고로 커널은 완벽하지 않기 때문에 버그가 있을 수 있으며 커널 버전이 달라지면 모니터링 지표가 제대로 수집되지 않을 가능성이 있다. 하나의 지표로만 모니터링하지말고 다양한 툴들과 지표를 조합해서 운영해야 한다.

# 4장 free 명령이 숨기고 있는 것들

CPU: 프로세스의 연산 과정에 필요한 리소스

메모리: 프로세스가 연산할 수 있는 공간을 제공해주는 리소스

이 메모리가 어떻게 활용되고 있는지를 파악하는 것은 CPU 사용률과 Load Average만큼 중요한 포인트이다.

```bash
free -m
```

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d662163-71a9-42a4-ac4d-87fff89c88a0/_2020-08-15__11.34.35.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6d662163-71a9-42a4-ac4d-87fff89c88a0/_2020-08-15__11.34.35.png)

free: 시스템에서 아직 사용하고 있지 않은 메모리의 양을 의미. 애플리케이션이 사용할 수도 있고 커널이 사용할 수도 있다.

buffers: 버퍼용도로 프로세스가 사용하는 영역은 아니고 시스템의 성능 향상을 위해서 커널이 사용하는 영역이다.

cached: 페이지 캐시라고 불리는 캐시 영역에 있는 메모리의 양을 의미한다. I/O관련 작업을 더 빠르게 진행하기 위해 커널에서 사용하고 있는 영역이다.

-/+ buffers/cache: 윗 줄에서 buffers와 cached를 제외한 양을 보여주는 것.

### buffers와 cached영역

커널은 블록 디바이스라고 부르는 디스크로부터 데이터를 읽거나 사용자의 데이터를 디스크에 저장한다. 하지만 디스크는 다른 장치들에 비해 매우 느리기 때문에 시스템 부하가 일어나기도 한다. 커널은 디스크에 대한 요청을 빠르게 하기 위해 메모리의 일부를 디스크 요청에 대한 캐싱 영역으로 할당해서 사용한다. 한 번 읽은 디스크의 내용을 메모리에 저장해서 재요청시 디스크로 요청하지 않고 메모리로 요청한다.

추가 설명

cached: 커널이 읽어야 할 데이터가 파일의 내용일 때.

buffers: 파일의 내용이 아닌 파일 시스템을 관리하기 위한 메타 데이터를 읽어올 때.

서버의 운영 기간이 길지 않을 때는 가용영역이 많다가 시간이 흐를수록 차게된다. 사용영역이 점점 더 커져서 일정 수준 이상이 되면 캐시영역으로 사용하던 영역을 애플리케이션이 사용할 수 있도록 메모리 관리 시스템에 반환한다.  이 과정을 거치다보면 더 이상 가용할 메모리가 없는 순간이 발생할 때 swap이 일어난다. 

### free보다 자세하기 보기

```bash
/proc/meminfo
```

SwapCached: swap으로 빠진 메모리 영역 중 다시 메모리로 돌아온 영역을 의미. 메모리가 확보되었지만 swap영역에서 해당 메모리 내용을 삭제하지 않는다. 추후 메모리 부족 상황을 대비하는 것. 그래서 swap이 다시 발생하더라도 조금이나마 I/O를 줄일 수 있다.

Active(anon): Page Cache영역을 제외한 메모리 영역을 의미한다. 주로 프로세스들이 사용하는 메모리영역을 지칭할 때 사용

Inactive(file): 커널이 I/O 성능 향상을 위해 사용하는 영역. buffers, cached 영역이 여기에 속한다.

### slab 메모리 영역

커널 역시 프로세스의 일종이기 때문에 메모리를 필요로 한다.

Slab: 커널이 직접 사용하는 영역

Slab영역 중 가장 많이 사용되는 캐시가 dentr와 inode_cache이다. 각각은 디렉터리의 계층 관계를 저장한다. 파일에 자주 접근하고 디렉터리의 생성/삭제가 빈번한 시스템이 있다면 Salb 메모리가 높아질 수 있다.

간혹 프로세스들이 사용하는 메모리 영역을 모두 더하고도 used와 맞지 않을 경우 Slab 메모리에서 누수가 발생하는 것일 수 도 있다. 메모리의 동작이 이상하다고 생각 될 때는 /proc/meminfo를 통해서 좀 더 정확한 정보를 수집하는 것이 필요.
