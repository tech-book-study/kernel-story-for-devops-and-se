# 2장 top을 통해 살펴보는 프로세스 정보들

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa91ffaa-6521-4a7a-8a39-1504c0b0bdc9/_2020-08-15__8.57.52.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa91ffaa-6521-4a7a-8a39-1504c0b0bdc9/_2020-08-15__8.57.52.png)

top 명령어로 서버 정보를 볼 수 있다.

3 days: 현재 구동 된지 3일 정도 되었음.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b299189-f3a0-4a76-b825-077137e6d83a/_2020-08-15__8.58.47.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3b299189-f3a0-4a76-b825-077137e6d83a/_2020-08-15__8.58.47.png)

PR: 프로세스 실행 우선순위

NI: PR을 얼마만큼 조정할 것인가

VIRT,RES,SHR: 프로세스가 사용하는 메모리의 양에 대한 것

VIRT: 할당된 가상메모리의 전체 크기. 

RES: 그 중에 실재로 메모리에 올려서 사용하고 있는 물리 메모리의 크기 (그렇기 때문에 실제 메모리 점유율이 높은 프로세스를 찾기 위해서는 RES 영역이 높은 프로세스를 찾아야 한다)

SHR: 다른 프로세스와 공유하고 있는 메모리의 크기

S: 프로세스의 상태를 나타낸다.

VIRT는 malloc과 같은 시스템 콜로 필요로 하는 메모리 영역을 할당해 달라고 요청을 하면 커널은 프로세스가 사용할 수 있는 가상 메모리주소를 전달해준다. ⇒ Memory Commit

그 후 프로세스가 할당받은 메모리 영역에 실제로 쓰기 작업을 하면 Page fault가 발생하며 실제 물리 메모리에 프로세스의 가상 메모리 공간을 매핑한다. 

한도 끝도 없이 늘어날까? → vm.overcommit_memory라는 파라미터로 그렇게 할 수 도있고 못하게 할 수도 있다. 

왜 즉시 할당하지 않는 것일까? → fork()와 같은 새로운 프로세스를 만들기 위한 콜을 처리해야 하기 때문이다.

### 프로세스의 상태

S - Process Status를 의미

D: uninterrubtable sleep 상태로 프로세스가 디스크 혹은 네트워크 작업을 하게 되면 요청이 도착할 때 까지 아무것도 할 수 없기 때문에 CPU에 대한 사용권을 다른 프로세스에게 넘기고 자신을 D로 마킹한다. 

R: 실행중인 프로세스이기 때문에 실제 CPU 자원을 소모한다.

S: sleeping 상태의 프로세스

T: strace등으로 프로세스의 시스템 콜을 추적하고 있는 상태로 보통의 시스템에서는 자주 볼 수 없다.

Z: zombie상태의 프로세스로 부모 프로세스가 죽은 자식 프로세스를 의미한다.

D 상태의 프로세스가 많다면 특정 요청을 기다리고 있는 것이고 다시 R상태로 돌아가야 하기 때문에 시스템 부하를 계산하는데 포함된다.

Z 프로세스는 시스템의 리소스를 차지하지 않아서 그 자체는 문제가 되지 않는다. 하지만 pid를 점유하고 있기 때문에 새로운 프로세스에 pid를 할당하지 못하여 고갈이 되는 문제가 발생할 수 있다.

### 프로세스의 우선순위

기본적으로 모든 프로세스는 20의 우선순위 값을 갖는다. 여기에 NI를 주면 우선순위값이 바뀌게 된다. 이 우선순위 값이 낮을 수록 더 빨리 실행된다.

# 3장 Load Average와 시스템 부하

Load Average는 얼마나 많은 프로세스가 실행 중 혹은 실행 대기 중이냐를 의미하는 수치이다. 이 값은 절대적이 아니라 상대적인데 계산과정이 시스템에 있는 CPU Core 수가 몇 개냐에 따라 달라지기 때문이다.

Kernel Timer가 주기적으로 프로세스의 개수를 센다.

Load Average가 높다는 것은 CPU를 사용하려는 프로세스가 많다는 것 뿐만 아니라 I/O쪽에 병목이 생겨서 I/O작업을 대기하는 프로세스가 많을 수도 있다는 이야기다. → 그렇기 때문에 Load Average가 높다고 단순히 CPU가 더 많은 장비를 사용하는 것으로 해결할 수 없다.

```bash
vmstat
```

vmstat 명령어로 시스템의 상태를 확인해 볼 수 있다.

r: 실행되기를 기다리거나 현재 실행되고 있는 프로세스의 개수

b: I/O를 위해 대기열에 있는 프로세스의 개수

참고로 커널은 완벽하지 않기 때문에 버그가 있을 수 있으며 커널 버전이 달라지면 모니터링 지표가 제대로 수집되지 않을 가능성이 있다. 하나의 지표로만 모니터링하지말고 다양한 툴들과 지표를 조합해서 운영해야 한다.
